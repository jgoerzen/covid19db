/* Database schema

Copyright (c) 2020 John Goerzen

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

use crate::dateutil::*;
use chrono::{Datelike, NaiveDate};
use julianday::JulianDay;
use serde::Deserialize;
use sqlx::Query;
use std::convert::TryFrom;

/** The `RTLive` struct represents a row in the `rtlive` table.  It is an instance
of `sqlx::FromRow` for the benefit of users of `sqlx::query_as`. */
#[derive(PartialEq, Clone, Debug, sqlx::FromRow, Deserialize)]
pub struct RTLive {
    pub date: String,
    pub date_julian: i32,
    pub date_year: i32,
    pub date_month: u32,
    pub date_day: u32,
    pub state: String,
    pub index: i64,
    pub mean: f64,
    pub median: f64,
    pub lower_80: f64,
    pub upper_80: f64,
    pub infections: f64,
    pub test_adjusted_positive: f64,
    pub test_adjusted_positive_raw: f64,
    pub tests: i64,
    pub new_tests: Option<i64>,
    pub new_cases: Option<i64>,
    pub new_deaths: Option<i64>,
}

impl RTLive {
    /// Bind all the parameters to a query, perhaps as generated by [`insert_str`].
    pub fn bind_query<'q>(self, query: Query<'q, sqlx::Sqlite>) -> Query<'q, sqlx::Sqlite> {
        // from schema
        // sed -e 's/ *\([^ ]*\).*/.bind(self.\1)/'
        query
            .bind(self.date)
            .bind(self.state)
            .bind(self.date_julian)
            .bind(self.date_year)
            .bind(i32::try_from(self.date_month).unwrap())
            .bind(i32::try_from(self.date_day).unwrap())
            .bind(self.index)
            .bind(self.mean)
            .bind(self.median)
            .bind(self.lower_80)
            .bind(self.upper_80)
            .bind(self.infections)
            .bind(self.test_adjusted_positive)
            .bind(self.test_adjusted_positive_raw)
            .bind(self.tests)
            .bind(self.new_tests)
            .bind(self.new_cases)
            .bind(self.new_deaths)
    }

    /// Gets an INSERT INTO string representing all the values in the table.
    pub fn insert_str() -> &'static str {
        "INSERT INTO cdataset VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    }

    /// Sets all date fields in the struct to appropriate representations of the
    /// given Julian date.
    pub fn set_date(&mut self, julian: i32) {
        let jd = JulianDay::new(julian);
        let nd = jd.to_date();
        self.date_julian = julian;
        self.date = format!("{}", nd.format("%Y-%m-%d"));
        self.date_year = nd.year();
        self.date_month = nd.month();
        self.date_day = nd.day();
    }

    #[allow(dead_code)]
    /// Sets all date fields in the struct to the appropriate representation of
    /// the given `JulianDay`.
    pub fn set_date_julianday(&mut self, jd: &JulianDay) {
        self.set_date(jd_to_day(jd));
    }

    #[allow(dead_code)]
    /// Sets all date fields in the struct to the appropriate representation of
    /// the given `NaiveDate` from the `chrono` package.
    pub fn set_date_naivedate(&mut self, nd: &NaiveDate) {
        self.set_date(nd_to_day(nd));
    }
}
